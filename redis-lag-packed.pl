#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/RedisLag.pm"} = <<'APP_REDISLAG';
  package App::RedisLag;
  use strict;
  use warnings;
  use Sys::Syslog;
  our $VERSION = '0.01';
  
  
  use Time::HiRes;
  use App::RedisLag::Redis;
  
  use constant KEY_PREFIX =>"RedisLag";
  
  sub new{
      my $class = shift;
  
      my $self = bless {
          key         => "ae9974b9-0ff5-4f7c-a572-4442fa0ef2d5-". $$,
          lag         => 0,
          timeout     => 120,
          wait        => 0.020,
          verbose     => 0,
          debug       => 0,
          daemon      => 0,
          set_time    => undef,
          master      => undef,
          slave       => undef,
          slave_host  => 'localhost',
          slave_port  => 6379,
          result_key  => 'slave',
          master_host => 'localhost',
          master_port => 6379,
          ring_buf    => [],
          @_,
      }, $class;
      $self->{result_key} = KEY_PREFIX."-".$self->{result_key};
      $self->{slave}  = App::RedisLag::Redis->new(host=>$self->{slave_host},port=>$self->{slave_port});
      $self->{master} = App::RedisLag::Redis->new(host=>$self->{master_host},port=>$self->{master_port});
      $self->{verbose} = 1 if $self->{debug};
      openlog("ReidsLag",'cons,pid', 'local5') if $self->{daemon};
      
      $self;
  }
  
  #アクセサ
  sub key {
      my $self = shift ;
      return ( $_[0] )?  $self->{key} = $_[0] : $self->{key};
  }
  sub lag {
      my $self = shift ;
      return ( $_[0] )?  $self->{lag} = $_[0] : $self->{lag};
  }
  sub timeout {
      my $self = shift ;
      return ( $_[0] )?  $self->{timeout} = $_[0] : $self->{timeout};
  }
  sub wait {
      my $self = shift ;
      return ( $_[0] )?  $self->{wait} = $_[0] : $self->{wait};
  }
  sub set_time {
      my $self = shift ;
      return ( $_[0] )?  $self->{set_time} = $_[0] : $self->{set_time};
  }
  sub add_ring_buf {
      my ($self,$value) = @_;
      push(@{$self->{ring_buf}},$value);
      if($#{$self->{ring_buf}} >= 600){
          shift(@{$self->{ring_buf}});
      }
  }
  
  sub sum {
      my ($self) = @_;
      my $time = Time::HiRes::time - 330;
      my $counter = 0;
      my $sum = 0;
      my $max = 0;
      my $min = $self->{timeout};
      foreach my $data (@{$self->{ring_buf}}){
          if($data->{date} > $time){
              $sum += $data->{time};
              $max = $data->{time} if($max<$data->{time});
              $min = $data->{time} if($min>$data->{time});
              $counter++;
          }
      }
      my $avg = $sum / $counter;
      return {avg=>$avg,max=>,$max,min=>$min,count=>$counter};
  }
  
  
  sub run {
      my ($self) = @_;
      my $time = $self->set_check_value();
      if(!$time){
          return $time;
      }
      $time  = $self->get_check_value($time);
      $self->puts('debug', "get check value: $time" ) if $self->{debug};
      if(!$time){
          return $time
      }
      $self->add_ring_buf({date=>time(),time=>$time});
      my $sum = $self->sum();
      my $value = "current:$time\tmin:$sum->{min}\tmax:$sum->{max}\tavg:$sum->{avg}";
      $self->{master}->set_value( $self->{result_key}, $value);
      $self->puts('debug', "set result_key:$self->{result_key} value: $value") if $self->{debug};
      if($self->{verbose}){
          my $message = "current=>$time";
          map{ $message .= ", $_=>$sum->{$_}" } keys %{$sum};
          $self->puts('debug', $message);
      }
  }
  
  sub get_result {
      my ($self) = @_;
      my $line = $self->{master}->get_value($self->{result_key});
      $self->puts('debug', "get result_key:$self->{result_key} value: $line") if $self->{debug};
      if($line =~ /\t/){
          my %kv;
          for (map { [ split ':', $_, 2 ] } split "\t", $line) {
              $kv{$_->[0]} = $_->[1];
          }
          return \%kv;
      }
      else{
          return 0;
      }
  }
  sub set_check_value {
      my ($self) = @_;
      $self->{set_time} = Time::HiRes::time;
      $self->puts('debug', "set check key: $self->{key} value: $self->{set_time}") if $self->{debug};
      if($self->{master}->set_value($self->{key},$self->{set_time})){
          return $self->{set_time};
      }
      return 0;
  }
  sub get_check_value {
      my ($self, $set_time) = @_;
      if($set_time){ $self->{set_time} = $set_time; }
      $set_time = $self->{set_time};
      if(!$set_time){
          return 0;
      }
      while(1){
          my $time = Time::HiRes::time;
          if($self->{timeout} < ($time - $set_time)){
              return $self->{timeout};
          }
          my $value = $self->{slave}->get_value($self->{key});
  		#if(!$value){ return $value; }
          if($set_time eq $value){
  			$self->puts('debug', "get check key: $self->{key} value: $value") if $self->{debug};
              return $time - $set_time;
          }
          Time::HiRes::sleep($self->{wait});
      }
  }
  
  sub puts {
      my ($self, $type,$message) = @_;
      if($self->{daemon}){
          syslog($type,$message);
      }
      else{
          print $message."\n";
      }
  
  }
  
  1;
  __END__
  
  =head1 NAME
  
  App::RedisLag -
  
  =head1 SYNOPSIS
  
    use App::RedisLag;
  
  =head1 DESCRIPTION
  
  App::RedisLag is
  
  =head1 AUTHOR
  
  YAMASAKI Masahide E<lt>masahide.y@gmail.comE<gt>
  
  =head1 SEE ALSO
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
APP_REDISLAG

$fatpacked{"App/RedisLag/Redis.pm"} = <<'APP_REDISLAG_REDIS';
  package App::RedisLag::Redis;
  use strict;
  use warnings;
  
  use IO::Socket::INET;
  use IO::Select;
  
  use constant EXPIRE => 600;
  
  sub new{
      my $class = shift;
  
      my $self = bless {
          socket      => undef,
          host        => "localhost",
          port        => 6379,
          pass        => undef,
          server      => undef,
          error_msg   => "",
          @_,
      }, $class;
      $self;
  }
  
  
  #アクセサ
  sub error_msg{
      my $self = shift ;
      return ( $_[0] )?  $self->{error_msg} = $_[0] : $self->{error_msg};
  }
  sub error {
      my ($self, $msg, $err_no) = @_;
      $self->{error_msg} = "$msg : $err_no";
      return 0;
  }
  
  sub connect {
      my ($self, $host, $port, $pass) = @_;
      if($self->{socket}){
          if($self->{socket}->connected){
              return $self; # 接続済み
          }
      }
      if($host){ $self->{host} = $host; }
      if($port){ $self->{port} = $port; }
      if($pass){ $self->{port} = $pass; }
      my $server = $self->{host}.":".$self->{port};
      $self->{server}=$server;
      my $sock = IO::Socket::INET->new(
          PeerAddr=>$server,
          TimeOut=>5,
          Blocking=>0,
          Proto=>'tcp');
      if($sock){
          if ($pass) {
              $sock->print("AUTH $pass \r\n");
              <$sock> || return $self->error("[$server] socket auth error",$!);
          }
      }
      else{
          return $self->error("socket connect error: $!",$!);
      }
      $self->{socket} = $sock;
  
      return $self;
  }
  
  sub close {
      my ($self) = @_;
      my $s = $self->{socket};
      if($s){
          if($s->connected){
              return $s->close();
          }
      }
      return $s;
  }
  
  sub DESTROY {
      my ($self) = @_;
      $self->close();
  }
  
  sub set_value {
      my ($self,$key,$value) = @_;
      my $status;
      my @lines = $self->write_read("SET $key $value\r\nEXPIRE $key ".EXPIRE."\r\n");
      if(!$#lines){ return 0;}
      if($#lines != 1 ||
         ($lines[0] !~ /^\+OK/ && $lines[1] !~ /^\:1/)
      ){
          return $self->error("[".$self->{server}."] get($key) socket read error", join(",",@lines));
      }
      return $self;
  }
  
  sub get_value {
      my ($self,$key) = @_;
      $self->connect();
      my @lines = $self->write_read("GET $key\r\n");
      if(!$#lines){ return 0;}
      if($#lines != 1){
          return $self->error("[".$self->{server}."] get($key) socket read error", -1);
      }
      return $lines[1];
  }
  
  
  sub write_read {
      my ($self,$in) = @_;
      $self->connect();
      my $s = $self->{socket};
      my $server = $self->{server};
      my $selecter = IO::Select->new;
      $selecter->add($s);
      $s->print($in);
      $s->flush();
      my $buf;
      my @lines;
      my @ready = $selecter->can_read(5);
      if(@ready){
          my $len = read($s, $buf, 4096);
          $selecter->remove($s);
          @lines = split(/\r\n/,$buf);
      }
      else{
          @lines = ();
      }
      $selecter->remove($s);
      return @lines;
  }
      
      
  
  
  1;
  __END__
  
  =head1 NAME
  
  
  
  
  
  =cut
APP_REDISLAG_REDIS

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE


use strict;
use warnings;
use IO::Socket;
use Getopt::Long qw(:config posix_default no_ignore_case gnu_compat bundling);
use Pod::Usage qw(pod2usage);
use POSIX ();

use App::RedisLag;

package main;

sub new{
    my $class = shift;
    my $self = bless {
        sleep       => undef,
        redis_lag   => undef,
        @_,
    }, $class;
    $self;
}

sub start {
    my $self = shift ;
    my $opt = +{};

    GetOptions(
        'd|daemon'          => \$opt->{daemon},
        'pidfile=s'         => \$opt->{pidfile},
        'v|verbose'         => \$opt->{verbose},
        's|slave_host=s'    => \$opt->{slave_host},
        'm|master_host=s'   => \$opt->{master_host},
        'p|port=i'          => \$opt->{port},
        'k|result_key=s'    => \$opt->{result_key},
        'master_port=i'     => \$opt->{master_port},
        'slave_port=i'      => \$opt->{slave_port},
        't|timeout=i'       => \$opt->{timeout},
        'sleep=i'           => \$opt->{sleep},
        'debug'             => \$opt->{debug},
        'munin_result'      => \$opt->{munin_result},
        'h|help'            => \$opt->{help},
    ) or pod2usage 1;
    if ($opt->{help}){
        pod2usage 1;
    }

    $self->{sleep} = $opt->{sleep}          || 1;
    my $timeout     = $opt->{timeout}       || 120;
    my $port        = $opt->{port}          || 6379;
    my $slave_port  = $opt->{slave_port}    || $port;
    my $master_port = $opt->{master_port}   || $port;
    my $slave_host  = $opt->{slave_host}  ? $opt->{slave_host}  : '127.0.0.1';
    my $master_host = $opt->{master_host} ? $opt->{master_host} : '127.0.0.1';
    my $result_key  = $opt->{result_key}  ? $opt->{result_key} : 'slave';
    my $pidfile     = $opt->{pidfile}  ? $opt->{pidfile} : '/tmp/redis-lag.pid';


    $self->{redis_lag} = App::RedisLag->new(
                            timeout     => $timeout,
                            verbose     => $opt->{verbose},
                            debug       => $opt->{debug},
                            daemon      => $opt->{daemon},
                            slave_host  => $slave_host,
                            slave_port  => $slave_port,
                            result_key  => $result_key,
                            master_host => $master_host,
                            master_port => $master_port,
                        );
                        
    if($opt->{munin_result}){
        my $result = $self->{redis_lag}->get_result();
		if($result){
			print "current.value $result->{current}\n";
			print "avg.value $result->{avg}\n";
			print "max.value $result->{max}\n";
			print "min.value $result->{min}\n";
		}
        exit 0;
    }

    if($opt->{debug} && !$opt->{daemon}){
        $self->run_loop();
    }
    if($opt->{daemon}){
        my $pid = fork();
        if(!defined $pid) {
            die "Faild to fork(): $!\n";
        }
        exit 0 if $pid; # 親プロセスは終了する
        POSIX::setsid() ||
            die "Could not detach from parent process\n";
        open(OUT, ">$pidfile");
        print OUT POSIX::getpid;
        close(OUT);
        $self->run_loop();
    }
    else{
        pod2usage 1;
    }

}

sub run_loop {
    my $self = shift ;
    while(1) {
        $self->{redis_lag}->run;
        sleep($self->{sleep});
    }
}
        

my $main = main->new();

$main->start();


__END__

=head1 NAME

redis-lag  - Reids replication lag Porring tool.


=head1 DESCRIPTION


Reids replication lag Porring tool.

=head1 USAGE

redis-lag [options]

=head2 Example

=over 4

=item redis-lag -d -m=10.0.0.1 -s=10.0.0.2 

=item redis-lag -d --sleep 5 -m=10.0.0.1 -s=10.0.0.2 

=item redis-lag -d --timeout 240 -m=10.0.0.1 -s=10.0.0.2 

=back

=head1 OPTIONS

=over 4

=item -d, --daemon  

start daemon

=item -v, --verbose

enable show verbose

=item -s, --slave_host 

set slave hostname or IP (default:127.0.0.1)

=item -m, --master_host

set master hostname or IP (default:127.0.0.1)

=item -p, --port

set master and slave port (default:6379)

=item -k, --result_key

set result key name (default:slave)

=item --master_port

set master port (default:-p,--port)

=item --slave_port

set slave port (default:-p,--port)

=item -t, --timeout

timeout (default:120)

=item --sleep

sleep time (default:1)

=item --debug

enable debug 

=item --munin_result

show munin plugin result 


=item -h, --help

show help

=back

=cut

